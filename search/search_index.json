{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About The RAKI ILP Benchmark is a benchmark developed for the RAKI project. The benchmark aims to evaluate Explainable AI systems, by asking a system the best fitting concept for a Learning Problem. Thus the system aims to describe the problem as best it can using an OWL ontology. What is a Learning Problem in this context? A learning problem is a set of positive examples and negative examples, whereas one example is an Individual contained in the ABox of the benchmarked OWL ontology. A learning problem may have also a gold standard concept which describes the learning problem. How does it work? Core Hobbit The RAKI ILP Benchmark is integrated into Hobbit . For further Information how the ILP benchmark works with Hobbit and a walkthrough on how to use it, have a look here Where can I find the code? The code is open source at https://github.com/dice-group/raki-ilp-benchmark and you can code with us if you want to :) Where do I submit a bug or enhancement? Please use the Github Issue Tracker at https://github.com/dice-group/raki-ilp-benchmark/issues","title":"About"},{"location":"#about","text":"The RAKI ILP Benchmark is a benchmark developed for the RAKI project. The benchmark aims to evaluate Explainable AI systems, by asking a system the best fitting concept for a Learning Problem. Thus the system aims to describe the problem as best it can using an OWL ontology.","title":"About"},{"location":"#what-is-a-learning-problem-in-this-context","text":"A learning problem is a set of positive examples and negative examples, whereas one example is an Individual contained in the ABox of the benchmarked OWL ontology. A learning problem may have also a gold standard concept which describes the learning problem.","title":"What is a Learning Problem in this context?"},{"location":"#how-does-it-work","text":"","title":"How does it work?"},{"location":"#core","text":"","title":"Core"},{"location":"#hobbit","text":"The RAKI ILP Benchmark is integrated into Hobbit . For further Information how the ILP benchmark works with Hobbit and a walkthrough on how to use it, have a look here","title":"Hobbit"},{"location":"#where-can-i-find-the-code","text":"The code is open source at https://github.com/dice-group/raki-ilp-benchmark and you can code with us if you want to :) Where do I submit a bug or enhancement? Please use the Github Issue Tracker at https://github.com/dice-group/raki-ilp-benchmark/issues","title":"Where can I find the code?"},{"location":"api/api/","text":"We will describe the Core API in this section Learning Problem Description A learning problem is an object containing of a set of positive uris, negative uris and an optional concept. The positive uris as well as the negative uris are named individuals of the ABox of an OWL Ontology. The concept is a class expression representation of this problem. It is build by concepts of the TBox of the Ontology. The learning problem is described using JSON. An Example: { \"positives\" : [ \"http://ontology.com/individuals/Human1\" , \"http://ontology.com/individuals/Human3\" , \"http://ontology.com/individuals/Human7\" ], \"negatives\" : [ \"http://ontology.com/individuals/Bear1\" , \"http://ontology.com/individuals/Dragon1\" , \"http://ontology.com/individuals/Eagle1\" ], \"concept\" : \"ontology:Human\" } Why is the gold standard concept optional Be aware: a Learning Problem does not have to contain a Concept. Imagine the following Ontology Class Human Class Dragon Disjoint: Humand, Dragon Human1 is Human Dragon1 is Dragon Human2 is Human Our Learning problem is: positives: [\"Human1\"] negatives: [\"Human2\", \"Dragon1\"] There is no concept within the TBox of the ontology representing the Learning Problem fully. API Creating a Learning Problem A learning problem can be created using the LearningProblemFactory . We will define positives and negatives each as a Collection<String> for simplicity. These collections contain the positive and negative uris. Creating from Lists. LearningProblem problem = LearningProblemFactory . create ( positives , negatives ); Creating from JSON String String jsonString = \"{ \\\"positives\\\": [...], \\\"negatives\\\": [...] }\" LearningProblem problem = LearningProblemFactory . parse ( jsonString ); Creating multiple Learning Problems from JSON String String jsonString = \"[ { \\\"positives\\\": [...], \\\"negatives\\\": [...] }, { \\\"positives\\\": [...], \\\"negatives\\\": [...] }]\" Set < LearningProblem > problems = LearningProblemFactory . readMany ( jsonString ); Read learning Problems from file Set < LearningProblem > problems = LearningProblemFactory . readMany ( new File ( \"learningProblems.json\" )); Concepts - Manchester Parser Description A Concept is a Class Expression derived from the TBox of an OWL Ontology. F.e. Human or Dragon describes the Concept of all humans and dragons. The Format used in RAKI ILP is the Manchester Syntax. API The API has a ManchesterSyntaxParser . This parser allows to parse a Manchester Syntax String to an OWLClassExpression and rendering an OWLClassExpression to a Manchester Syntax String. It needs a main ontology, and an optional OWL base ontology (containing the basics of OWL, such as owl:Thing ). Furhter on it ManchesterSyntaxParser parser = new ManchesterSyntaxParser ( mainOntology , baseOntology ); OWLClassExpression expr = parser . parse ( \"ontology:Human or ontology:Dragon\" ); # concept = ' Human or Dragon ' String concept = parser . render ( expr ); Benchmark Configuration Description The Benchmark Configuration consists of three elements The benchmark name The file path containing the Ontology The file path containing the learning problems Configurations can be read from a YAML file or created simply by using the Configuration constructor The YAML file has to look like this datasets : - name : \"MyBenchmarkName1\" learningProblem : \"/path/to/learningProblems1.json\" dataset : \"/path/to/ontology1.owl\" - name : \"MyBenchmarkName2\" learningProblem : \"/path/to/learningProblems2.json\" dataset : \"/path/to/ontology2.owl\" The Learning problem has to be a json file. An example can be seen above. API Creating from file //load all Configurations Configurations confs = Configurations . load ( new File ( \"/path/to/config.yml\" )); //retrieve the ones with your benchmark name Configuration myBenchmark = confs . getConfiguration ( \"MyBenchmarkName1\" ); Using the Configuration to retrieve the OWLOntology and the Set of LearningProblems OWLOntology ontology = configuration . readOntology (); Set < LearningProblem > problems = configuration . readLearningProblems (); Metrics Currently, the core can calculate two metrics F1-Measure, Precision and Recall The Concept Length of a Concept F1-Measure The F1 measure will be calculated using the F1MeasureCalculator . The calculator will calculate the f1-score, precision and recall from the true positives , false positives and false negatives provided and stores the results internally as well to calculate the macro and micro f1 measure later on. Create an F1Result F1MeasureCalculator calculator = new F1MeasureCalculator (); F1Result result = calculator . addF1Measure ( truePositives , falsePositives , falseNegatives ); The results can then be queried from the F1Result object double precision = result . getPrecision (); double recall = result . getRecall (); double f1score = result . getF1measure (); Create macro and micro F1 scores F1MeasureCalculator calculator = new F1MeasureCalculator (); // Calculate and add the F1 scores for some truePositives, falsePositives and falseNegatives calculator . addF1Measure ( truePositives , falsePositives , falseNegatives ); calculator . addF1Measure ( truePositives , falsePositives , falseNegatives ); //the scores will be stored internally and be used to calculate the Micro and Macro F1Measures F1Result macroResults = calculator . calculateMacroF1Measure (); F1Result microResults = calculator . calculateMicroF1Measure (); To clear the stored values use the clear method calculator . clear (); Concept Length The concept length of an OWLClassExpression can be calculated by using the ConceptLengthCalculator . Currently, only the following syntax structures are supported: AND OR SOME ALL NOT ConceptLengthCalculator calculator = new ConceptLengthCalculator (); //Create your concept/class expression OWLClassExpression expr = ... ; calculator . render ( expr ); int lengthOfExpr = calculator . getConceptLength (); Evaluator Description The Evaluator evaluates a set of Learning problems against a set of concepts. Additionally, the Evaluator can evaluate a single Learning Problem against a single concept. The single evaluation will return a ResultContainer containing the F1 Measures and Concept Length. If either the Evaluator was used, by using a set of Learning Problem and Concept pairs or the single evaluation was executed multiple times, the Evaluator can return the Macro and Micro F1 measures as well as all concept lengths. It needs a main Ontology, the owl base Ontology (can be empty though) and if the gold standard concept should be used instead of the positive and negative uris inside the learning problems. API Create the evaluator boolean useConcepts = false ; Evaluator evaluator = new Evaluator ( mainOntology , owlBaseOntology , useConcepts ); Execute a single execution //create your learning problem LearningProblem problem = ...; //create the answer concept String concept = \"ontology:Human\" ResultContainer container = evaluator . evaluate ( learningProblem , concept ); int conceptLength = container . getConceptLength (); F1Result f1result = container . getF1Result (); Execute multiple LearningProblem, Concept pairs. Each Pair consists of a Learning Problem and the corresponding concept. //Create your problem Pairs Set < Pair < LearningProblem , String >> problemPairs = ...; evaluator . evaluate ( problemPairs ); //Now we can retrieve the macro and micro F1 measures, as well as all Concept Lengths as following F1Result macroF1 = evaluator . getMacroF1Measure (); F1Result microF1 = evaluator . getMicroF1Measure (); List < Integer > conceptLengths = evaluator . getConceptLengths (); Further on all available Metrics can be printed as a table to the standard output using: evaluator . printTable (); Table Printer The TablePrinter is a helper class to print a table in a kinda nice format. List < String > header = new ArrayList <> (); header . add ( \"Name\" ); header . add ( \"Description\" ); header . add ( \"Salary\" ); List < List < Object >> table = new ArrayList <> (); table . add ( Lists . newArrayList ( \"Joe\" , \"Consultant in IT\" , 5000 )); table . add ( Lists . newArrayList ( \"Mary\" , \"Engineer in IT\" , 8000 )); table . add ( Lists . newArrayList ( \"Lina\" , \"Security Expert in IT\" , 9500 )); TablePrinter . print ( table , header , \"%10s %20s %5d\" ); will produce --------------------------------------------------------------------------- Name Description Salary --------------------------------------------------------------------------- Joe Consultant in IT 5000 Mary Engineer in IT 8000 Lina Security Expert in IT 9500 ---------------------------------------------------------------------------","title":"Api"},{"location":"api/api/#learning-problem","text":"","title":"Learning Problem"},{"location":"api/api/#description","text":"A learning problem is an object containing of a set of positive uris, negative uris and an optional concept. The positive uris as well as the negative uris are named individuals of the ABox of an OWL Ontology. The concept is a class expression representation of this problem. It is build by concepts of the TBox of the Ontology. The learning problem is described using JSON. An Example: { \"positives\" : [ \"http://ontology.com/individuals/Human1\" , \"http://ontology.com/individuals/Human3\" , \"http://ontology.com/individuals/Human7\" ], \"negatives\" : [ \"http://ontology.com/individuals/Bear1\" , \"http://ontology.com/individuals/Dragon1\" , \"http://ontology.com/individuals/Eagle1\" ], \"concept\" : \"ontology:Human\" }","title":"Description"},{"location":"api/api/#why-is-the-gold-standard-concept-optional","text":"Be aware: a Learning Problem does not have to contain a Concept. Imagine the following Ontology Class Human Class Dragon Disjoint: Humand, Dragon Human1 is Human Dragon1 is Dragon Human2 is Human Our Learning problem is: positives: [\"Human1\"] negatives: [\"Human2\", \"Dragon1\"] There is no concept within the TBox of the ontology representing the Learning Problem fully.","title":"Why is the gold standard concept optional"},{"location":"api/api/#api","text":"","title":"API"},{"location":"api/api/#creating-a-learning-problem","text":"A learning problem can be created using the LearningProblemFactory . We will define positives and negatives each as a Collection<String> for simplicity. These collections contain the positive and negative uris.","title":"Creating a Learning Problem"},{"location":"api/api/#creating-from-lists","text":"LearningProblem problem = LearningProblemFactory . create ( positives , negatives );","title":"Creating from Lists."},{"location":"api/api/#creating-from-json-string","text":"String jsonString = \"{ \\\"positives\\\": [...], \\\"negatives\\\": [...] }\" LearningProblem problem = LearningProblemFactory . parse ( jsonString );","title":"Creating from JSON String"},{"location":"api/api/#creating-multiple-learning-problems-from-json-string","text":"String jsonString = \"[ { \\\"positives\\\": [...], \\\"negatives\\\": [...] }, { \\\"positives\\\": [...], \\\"negatives\\\": [...] }]\" Set < LearningProblem > problems = LearningProblemFactory . readMany ( jsonString );","title":"Creating multiple Learning Problems from JSON String"},{"location":"api/api/#read-learning-problems-from-file","text":"Set < LearningProblem > problems = LearningProblemFactory . readMany ( new File ( \"learningProblems.json\" ));","title":"Read learning Problems from file"},{"location":"api/api/#concepts-manchester-parser","text":"","title":"Concepts - Manchester Parser"},{"location":"api/api/#description_1","text":"A Concept is a Class Expression derived from the TBox of an OWL Ontology. F.e. Human or Dragon describes the Concept of all humans and dragons. The Format used in RAKI ILP is the Manchester Syntax.","title":"Description"},{"location":"api/api/#api_1","text":"The API has a ManchesterSyntaxParser . This parser allows to parse a Manchester Syntax String to an OWLClassExpression and rendering an OWLClassExpression to a Manchester Syntax String. It needs a main ontology, and an optional OWL base ontology (containing the basics of OWL, such as owl:Thing ). Furhter on it ManchesterSyntaxParser parser = new ManchesterSyntaxParser ( mainOntology , baseOntology ); OWLClassExpression expr = parser . parse ( \"ontology:Human or ontology:Dragon\" ); # concept = ' Human or Dragon ' String concept = parser . render ( expr );","title":"API"},{"location":"api/api/#benchmark-configuration","text":"","title":"Benchmark Configuration"},{"location":"api/api/#description_2","text":"The Benchmark Configuration consists of three elements The benchmark name The file path containing the Ontology The file path containing the learning problems Configurations can be read from a YAML file or created simply by using the Configuration constructor The YAML file has to look like this datasets : - name : \"MyBenchmarkName1\" learningProblem : \"/path/to/learningProblems1.json\" dataset : \"/path/to/ontology1.owl\" - name : \"MyBenchmarkName2\" learningProblem : \"/path/to/learningProblems2.json\" dataset : \"/path/to/ontology2.owl\" The Learning problem has to be a json file. An example can be seen above.","title":"Description"},{"location":"api/api/#api_2","text":"Creating from file //load all Configurations Configurations confs = Configurations . load ( new File ( \"/path/to/config.yml\" )); //retrieve the ones with your benchmark name Configuration myBenchmark = confs . getConfiguration ( \"MyBenchmarkName1\" ); Using the Configuration to retrieve the OWLOntology and the Set of LearningProblems OWLOntology ontology = configuration . readOntology (); Set < LearningProblem > problems = configuration . readLearningProblems ();","title":"API"},{"location":"api/api/#metrics","text":"Currently, the core can calculate two metrics F1-Measure, Precision and Recall The Concept Length of a Concept","title":"Metrics"},{"location":"api/api/#f1-measure","text":"The F1 measure will be calculated using the F1MeasureCalculator . The calculator will calculate the f1-score, precision and recall from the true positives , false positives and false negatives provided and stores the results internally as well to calculate the macro and micro f1 measure later on.","title":"F1-Measure"},{"location":"api/api/#create-an-f1result","text":"F1MeasureCalculator calculator = new F1MeasureCalculator (); F1Result result = calculator . addF1Measure ( truePositives , falsePositives , falseNegatives ); The results can then be queried from the F1Result object double precision = result . getPrecision (); double recall = result . getRecall (); double f1score = result . getF1measure ();","title":"Create an F1Result"},{"location":"api/api/#create-macro-and-micro-f1-scores","text":"F1MeasureCalculator calculator = new F1MeasureCalculator (); // Calculate and add the F1 scores for some truePositives, falsePositives and falseNegatives calculator . addF1Measure ( truePositives , falsePositives , falseNegatives ); calculator . addF1Measure ( truePositives , falsePositives , falseNegatives ); //the scores will be stored internally and be used to calculate the Micro and Macro F1Measures F1Result macroResults = calculator . calculateMacroF1Measure (); F1Result microResults = calculator . calculateMicroF1Measure (); To clear the stored values use the clear method calculator . clear ();","title":"Create macro and micro F1 scores"},{"location":"api/api/#concept-length","text":"The concept length of an OWLClassExpression can be calculated by using the ConceptLengthCalculator . Currently, only the following syntax structures are supported: AND OR SOME ALL NOT ConceptLengthCalculator calculator = new ConceptLengthCalculator (); //Create your concept/class expression OWLClassExpression expr = ... ; calculator . render ( expr ); int lengthOfExpr = calculator . getConceptLength ();","title":"Concept Length"},{"location":"api/api/#evaluator","text":"","title":"Evaluator"},{"location":"api/api/#description_3","text":"The Evaluator evaluates a set of Learning problems against a set of concepts. Additionally, the Evaluator can evaluate a single Learning Problem against a single concept. The single evaluation will return a ResultContainer containing the F1 Measures and Concept Length. If either the Evaluator was used, by using a set of Learning Problem and Concept pairs or the single evaluation was executed multiple times, the Evaluator can return the Macro and Micro F1 measures as well as all concept lengths. It needs a main Ontology, the owl base Ontology (can be empty though) and if the gold standard concept should be used instead of the positive and negative uris inside the learning problems.","title":"Description"},{"location":"api/api/#api_3","text":"Create the evaluator boolean useConcepts = false ; Evaluator evaluator = new Evaluator ( mainOntology , owlBaseOntology , useConcepts ); Execute a single execution //create your learning problem LearningProblem problem = ...; //create the answer concept String concept = \"ontology:Human\" ResultContainer container = evaluator . evaluate ( learningProblem , concept ); int conceptLength = container . getConceptLength (); F1Result f1result = container . getF1Result (); Execute multiple LearningProblem, Concept pairs. Each Pair consists of a Learning Problem and the corresponding concept. //Create your problem Pairs Set < Pair < LearningProblem , String >> problemPairs = ...; evaluator . evaluate ( problemPairs ); //Now we can retrieve the macro and micro F1 measures, as well as all Concept Lengths as following F1Result macroF1 = evaluator . getMacroF1Measure (); F1Result microF1 = evaluator . getMicroF1Measure (); List < Integer > conceptLengths = evaluator . getConceptLengths (); Further on all available Metrics can be printed as a table to the standard output using: evaluator . printTable ();","title":"API"},{"location":"api/api/#table-printer","text":"The TablePrinter is a helper class to print a table in a kinda nice format. List < String > header = new ArrayList <> (); header . add ( \"Name\" ); header . add ( \"Description\" ); header . add ( \"Salary\" ); List < List < Object >> table = new ArrayList <> (); table . add ( Lists . newArrayList ( \"Joe\" , \"Consultant in IT\" , 5000 )); table . add ( Lists . newArrayList ( \"Mary\" , \"Engineer in IT\" , 8000 )); table . add ( Lists . newArrayList ( \"Lina\" , \"Security Expert in IT\" , 9500 )); TablePrinter . print ( table , header , \"%10s %20s %5d\" ); will produce --------------------------------------------------------------------------- Name Description Salary --------------------------------------------------------------------------- Joe Consultant in IT 5000 Mary Engineer in IT 8000 Lina Security Expert in IT 9500 ---------------------------------------------------------------------------","title":"Table Printer"},{"location":"hobbit/add-benchmark/","text":"Add a Benchmark Dataset Preliminaries Learning Problem in json Ontology containing TBox and Abox Check LPBenchGen to generate Add Dataset to Code to data folder to benchmark.yml Add Dataset to Benchmark.ttl (Optional) Add Dataset to the Ontolearn System","title":"Add a Benchmark Dataset"},{"location":"hobbit/add-benchmark/#add-a-benchmark-dataset","text":"","title":"Add a Benchmark Dataset"},{"location":"hobbit/add-benchmark/#preliminaries","text":"Learning Problem in json Ontology containing TBox and Abox Check LPBenchGen to generate","title":"Preliminaries"},{"location":"hobbit/add-benchmark/#add-dataset-to-code","text":"to data folder to benchmark.yml","title":"Add Dataset to Code"},{"location":"hobbit/add-benchmark/#add-dataset-to-benchmarkttl","text":"","title":"Add Dataset to Benchmark.ttl"},{"location":"hobbit/add-benchmark/#optional-add-dataset-to-the-ontolearn-system","text":"","title":"(Optional) Add Dataset to the Ontolearn System"},{"location":"hobbit/add-system/","text":"Add A System Add Raki Hobbit Library Create your System Add System to Hobbit Create a system.ttl Create the Docker container","title":"Add A System"},{"location":"hobbit/add-system/#add-a-system","text":"","title":"Add A System"},{"location":"hobbit/add-system/#add-raki-hobbit-library","text":"","title":"Add Raki Hobbit Library"},{"location":"hobbit/add-system/#create-your-system","text":"","title":"Create your System"},{"location":"hobbit/add-system/#add-system-to-hobbit","text":"","title":"Add System to Hobbit"},{"location":"hobbit/add-system/#create-a-systemttl","text":"","title":"Create a system.ttl"},{"location":"hobbit/add-system/#create-the-docker-container","text":"","title":"Create the Docker container"},{"location":"hobbit/overview/","text":"In this section we will explain the overview of Hobbit. Usage Parameters Workflow","title":"Overview"},{"location":"hobbit/overview/#usage","text":"","title":"Usage"},{"location":"hobbit/overview/#parameters","text":"","title":"Parameters"},{"location":"hobbit/overview/#workflow","text":"","title":"Workflow"},{"location":"hobbit/setup/","text":"RAKI ILP Benchmark integration for HOBBIT. This setup will guide you through the steps to create the RAKI ILP Benchmark on your local machine using a local Hobbit. Preparations You need an Account on Hobbit at https://git.project-hobbit.eu and permission on the project You need to use a local HOBBIT deployment if you want to use private datasets You need to Clone this Repository 2. Use a local HOBBIT deployment See https://hobbit-project.github.io/quick_guide.html how to deploy HOBBIT locally and make sure to set DOCKER_AUTOPULL: 0 in the config as described in https://hobbit-project.github.io/parameters_env.html services : platform-controller : image : hobbitproject/hobbit-platform-controller:latest networks : - hobbit - hobbit-core environment : ... DOCKER_AUTOPULL : 0 3. Clone this Repo git clone https://github.com/dice-group/raki-ilp-benchmark cd raki-ilp-benchmark git checkout raki-private Add a Dataset This involves a few straight forward steps You need to create a URL we call benchmark ID for HOBBIT Add the dataset(s) to this repository and set the configurations accordingly, so the system recognizes your dataset Add the benchmark ID to HOBBIT. Create a BENCHMARK ID Create a benchmark ID like the following http://w3id.org/raki/hobbit/vocab#YOUR-BENCHMARK-NAME we will use YOUR_BENCHMARK_URI as a placeholder fo this ID throughout this README. How to add a Dataset Create the directory where you'll put your benchmark dataset in. cd raki-datagenerator/data/ mkdir YOUR_BENCHMARK_NAME cd YOUR_BENCHMARK_NAME/ Add your Ontology ontology.owl into raki-datagenerator/data/YOUR_BENCHMARK_NAME/ Be aware that your Ontology needs an Ontology ID which you can set in the ontology like the following. Let's assume that your ID is http://example.com/MY-ID <rdf:RDF xmlns= \"http://example.com/MY-ID\" xml:base= \"http://example.com/MY-ID\" xmlns:rdf= \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:owl= \"http://www.w3.org/2002/07/owl#\" xmlns:xml= \"http://www.w3.org/XML/1998/namespace\" xmlns:dl= \"http://dl-learner.org/benchmark/dataset/animals/\" xmlns:xsd= \"http://www.w3.org/2001/XMLSchema#\" xmlns:rdfs= \"http://www.w3.org/2000/01/rdf-schema#\" > <owl:Ontology rdf:about= \"http://example.com/MY-ID\" /> <!-- YOUR ONTOLOGY HERE --> </rdf:RDF> Now create a file called lp.json where you put the learning problems in the following format: [ { \"positives\" : [ \"http://example.com/positive1\" , \"http://example.com/positive2\" ... ], \"negatives\" : [ \"http://example.com/negative1\" , \"http://example.com/negative2\" ... ] }, ... ] Add the dataset to the benchmark configuration Edit raki-datagenerator/src/main/resources/benchmark.yaml and add the following at the end - name : \"YOUR_BENCHMARK_URI\" dataset : \"/raki/data/YOUR-BENCHMARK-NAME/ontology.owl\" learningProblem : \"/raki/data/YOUR-BENCHMARK-NAME/lp.json\" Add the dataset to HOBBIT This is the only step which is public. go to https://git.project-hobbit.eu/raki/raki-private/raki-benchmark and edit the benchmark.ttl Add the following to the end <YOUR_BENCHMARK_URI> a raki : Datasets; rdfs : label \"My Benchmark Name\"@en; rdfs : comment \"Description of My Benchmark Name\"@en . Be aware: Folks may see the name of the dataset. (Use an obscured one if you don't want them, however it needs to be obscured in the previous steps as well.) Use Ontolearn as a system Get pre defined embeddings and trained datasets cd raki-system-adapters && https://github.com/dice-group/Ontolearn/blob/main/embeddings.zip?raw=true -O embeddings.zip && cd .. Unzip them to add your datasets cd raki-system-adapters && unzip pre_trained_agents.zip && cd .. cd raki-system-adapters && unzip embeddings.zip && cd .. To use the Ontolearn adapter you need to create embeddings in https://github.com/dice-group/DAIKIRI-Embedding using ConEx on your dataset. add the embeddings and pre-trained agents to the corresponding folder in embeddings/ConEx_YOUR_DATASET_NAME/ConEx_entity_embeddings.csv and pre_trained_agents/YOUR_DATASET_NAME/DrillHeuristic_averaging/DrillHeuristic_averaging.pth Add in raki-system-adapter/src/main/resources/drill-mapping.properties using your previous declared Ontology ID (e.g. http://example.com/MY-ID ) http\\ : //example.com/MY-ID=ConEx_YOUR_DATASET_NAME/ConEx_entity_embeddings.csv, YOUR_DATASET_NAME/DrillHeuristic_averaging/DrillHeuristic_averaging.pth Now we need to zip the embeddings and pre_trained_agents again cd raki-system-adapters && zip -r pre_trained_agents.zip pre_trained_agents/ && cd .. cd raki-system-adapters && zip -r embeddings.zip embeddings/ && cd .. Build Set build.sh to an executable chmod +x build.sh If you've done your changes: ./build.sh It will automatically build the Docker images for the private RAKI benchmark. Access Raki-private As the RAKI-private benchmark should be only accessible by members of the raki-private group add to the docker-compose.yml the following services : platform-controller : image : hobbitproject/hobbit-platform-controller:latest networks : - hobbit - hobbit-core environment : ... GITLAB_USER : \"YOUR_USER_NAME\" GITLAB_EMAIL : \"YOUR_EMAIL\" GITLAB_TOKEN : \"YOUR_TOKEN\" YOUR_TOKEN is a gitlab token you have to create in https://git.project-hobbit.eu -> Settings -> Access Token -> check at least (api, read_repository, read_registry) Now start the platform and go to http://localhost:8181 (Keycloack) -> Admin Console and login using the Keycloack admin account (see https://hobbit-project.github.io/quick_guide.html for initial credentials) Now add a dummy user (users -> add users) with the same name and email as your token user. Click again on Users and on view all users click on the ID of your newly created dummy user and click on the Credentials tab. Create a password for your user. Now you can login into localhost:8080 using your dummy user and should be able to access the Raki ILP Benchmark - Priv .","title":"Setup"},{"location":"hobbit/setup/#preparations","text":"You need an Account on Hobbit at https://git.project-hobbit.eu and permission on the project You need to use a local HOBBIT deployment if you want to use private datasets You need to Clone this Repository","title":"Preparations"},{"location":"hobbit/setup/#2-use-a-local-hobbit-deployment","text":"See https://hobbit-project.github.io/quick_guide.html how to deploy HOBBIT locally and make sure to set DOCKER_AUTOPULL: 0 in the config as described in https://hobbit-project.github.io/parameters_env.html services : platform-controller : image : hobbitproject/hobbit-platform-controller:latest networks : - hobbit - hobbit-core environment : ... DOCKER_AUTOPULL : 0","title":"2. Use a local HOBBIT deployment"},{"location":"hobbit/setup/#3-clone-this-repo","text":"git clone https://github.com/dice-group/raki-ilp-benchmark cd raki-ilp-benchmark git checkout raki-private","title":"3. Clone this Repo"},{"location":"hobbit/setup/#add-a-dataset","text":"This involves a few straight forward steps You need to create a URL we call benchmark ID for HOBBIT Add the dataset(s) to this repository and set the configurations accordingly, so the system recognizes your dataset Add the benchmark ID to HOBBIT.","title":"Add a Dataset"},{"location":"hobbit/setup/#create-a-benchmark-id","text":"Create a benchmark ID like the following http://w3id.org/raki/hobbit/vocab#YOUR-BENCHMARK-NAME we will use YOUR_BENCHMARK_URI as a placeholder fo this ID throughout this README.","title":"Create a BENCHMARK ID"},{"location":"hobbit/setup/#how-to-add-a-dataset","text":"Create the directory where you'll put your benchmark dataset in. cd raki-datagenerator/data/ mkdir YOUR_BENCHMARK_NAME cd YOUR_BENCHMARK_NAME/ Add your Ontology ontology.owl into raki-datagenerator/data/YOUR_BENCHMARK_NAME/ Be aware that your Ontology needs an Ontology ID which you can set in the ontology like the following. Let's assume that your ID is http://example.com/MY-ID <rdf:RDF xmlns= \"http://example.com/MY-ID\" xml:base= \"http://example.com/MY-ID\" xmlns:rdf= \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:owl= \"http://www.w3.org/2002/07/owl#\" xmlns:xml= \"http://www.w3.org/XML/1998/namespace\" xmlns:dl= \"http://dl-learner.org/benchmark/dataset/animals/\" xmlns:xsd= \"http://www.w3.org/2001/XMLSchema#\" xmlns:rdfs= \"http://www.w3.org/2000/01/rdf-schema#\" > <owl:Ontology rdf:about= \"http://example.com/MY-ID\" /> <!-- YOUR ONTOLOGY HERE --> </rdf:RDF> Now create a file called lp.json where you put the learning problems in the following format: [ { \"positives\" : [ \"http://example.com/positive1\" , \"http://example.com/positive2\" ... ], \"negatives\" : [ \"http://example.com/negative1\" , \"http://example.com/negative2\" ... ] }, ... ]","title":"How to add a Dataset"},{"location":"hobbit/setup/#add-the-dataset-to-the-benchmark-configuration","text":"Edit raki-datagenerator/src/main/resources/benchmark.yaml and add the following at the end - name : \"YOUR_BENCHMARK_URI\" dataset : \"/raki/data/YOUR-BENCHMARK-NAME/ontology.owl\" learningProblem : \"/raki/data/YOUR-BENCHMARK-NAME/lp.json\"","title":"Add the dataset to the benchmark configuration"},{"location":"hobbit/setup/#add-the-dataset-to-hobbit","text":"This is the only step which is public. go to https://git.project-hobbit.eu/raki/raki-private/raki-benchmark and edit the benchmark.ttl Add the following to the end <YOUR_BENCHMARK_URI> a raki : Datasets; rdfs : label \"My Benchmark Name\"@en; rdfs : comment \"Description of My Benchmark Name\"@en . Be aware: Folks may see the name of the dataset. (Use an obscured one if you don't want them, however it needs to be obscured in the previous steps as well.)","title":"Add the dataset to HOBBIT"},{"location":"hobbit/setup/#use-ontolearn-as-a-system","text":"Get pre defined embeddings and trained datasets cd raki-system-adapters && https://github.com/dice-group/Ontolearn/blob/main/embeddings.zip?raw=true -O embeddings.zip && cd .. Unzip them to add your datasets cd raki-system-adapters && unzip pre_trained_agents.zip && cd .. cd raki-system-adapters && unzip embeddings.zip && cd .. To use the Ontolearn adapter you need to create embeddings in https://github.com/dice-group/DAIKIRI-Embedding using ConEx on your dataset. add the embeddings and pre-trained agents to the corresponding folder in embeddings/ConEx_YOUR_DATASET_NAME/ConEx_entity_embeddings.csv and pre_trained_agents/YOUR_DATASET_NAME/DrillHeuristic_averaging/DrillHeuristic_averaging.pth Add in raki-system-adapter/src/main/resources/drill-mapping.properties using your previous declared Ontology ID (e.g. http://example.com/MY-ID ) http\\ : //example.com/MY-ID=ConEx_YOUR_DATASET_NAME/ConEx_entity_embeddings.csv, YOUR_DATASET_NAME/DrillHeuristic_averaging/DrillHeuristic_averaging.pth Now we need to zip the embeddings and pre_trained_agents again cd raki-system-adapters && zip -r pre_trained_agents.zip pre_trained_agents/ && cd .. cd raki-system-adapters && zip -r embeddings.zip embeddings/ && cd ..","title":"Use Ontolearn as a system"},{"location":"hobbit/setup/#build","text":"Set build.sh to an executable chmod +x build.sh If you've done your changes: ./build.sh It will automatically build the Docker images for the private RAKI benchmark.","title":"Build"},{"location":"hobbit/setup/#access-raki-private","text":"As the RAKI-private benchmark should be only accessible by members of the raki-private group add to the docker-compose.yml the following services : platform-controller : image : hobbitproject/hobbit-platform-controller:latest networks : - hobbit - hobbit-core environment : ... GITLAB_USER : \"YOUR_USER_NAME\" GITLAB_EMAIL : \"YOUR_EMAIL\" GITLAB_TOKEN : \"YOUR_TOKEN\" YOUR_TOKEN is a gitlab token you have to create in https://git.project-hobbit.eu -> Settings -> Access Token -> check at least (api, read_repository, read_registry) Now start the platform and go to http://localhost:8181 (Keycloack) -> Admin Console and login using the Keycloack admin account (see https://hobbit-project.github.io/quick_guide.html for initial credentials) Now add a dummy user (users -> add users) with the same name and email as your token user. Click again on Users and on view all users click on the ID of your newly created dummy user and click on the Credentials tab. Create a password for your user. Now you can login into localhost:8080 using your dummy user and should be able to access the Raki ILP Benchmark - Priv .","title":"Access Raki-private"}]}